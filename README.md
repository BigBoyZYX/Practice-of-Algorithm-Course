# Practice-of-Algorithm-Course
IDE工具：PyCharm

程序语言：Python 3.7

一、排序算法

1.题目要求

分别针对随机生成的若干组整数序列（比如规模为1000个数，10000个数，100000个数）进行排序，排序算法使用四种方法，至少包括以下三种经典方法：插入排序算法、合并排序算法和快速排序算法。

2.思路

调用random模块的randint方法，生成数组l1，包含1000个随机数。l1用于冒泡排序，将l1深拷贝为l2，l3，l4，l5，分别用于插入排序，合并排序，快速排序以及降序插入排序。

3.分析

（1）冒泡排序：空间复杂度为O(1)，平均情况时间复杂度O(n^2)，最好情况时间复杂度O(n)。
因为元素相等时不会移动位置，是一种稳定的排序算法（与代码的比较符写法有关）。

（2）插入排序：空间复杂度为O(1)，最好情况时间复杂度是O(n)，最坏情况时间复杂度为O(n^2)。最好情况出现在给的数组已经排好序，最坏情况出现在给的数组逆序排列。
因为元素相等时不会移动位置，是一种稳定的排序算法（与代码的比较符写法有关）。

（3）合并排序：最好情况时间复杂度是O(nlogn)，最坏情况时间复杂度是O(n^2)。最坏情况出现在分解原问题时，每次都只能分成两组。
合并排序是一种稳定的排序算法。

（4）快速排序：最好情况时间复杂度和平均情况时间复杂度是O(nlog2n)，最坏情况时间复杂度是O(n^2)。为了避免最坏情况，可以随机化选取主元。
相同的元素会因为位置分割开，是一种不稳定的排序算法。

4.如果随机生成了10个数（以[2，3，5，7，9，6，4，1，0，8]为例），在使用快速排序进行排序时，尝试给出数组的演化情况。

（1）首先将2作为主元，应用2个变量i和j分别指向序列左端和右端；

2	3	5	7	9	6	4	1	0	8

（2）j从左往右寻找一个小于2的数，i从右往左寻找一个大于2的数，找到了0和3进行第一次交换，继续搜索；

2	0	5	7	9	6	4	1	3	8

（3）1和5进行第二次交换，当i和j都到1数值1时，表明第一轮交换结束；

2	0	1	7	9	6	4	5	3	8

……

2	0	1	7	9	6	4	5	3	8

（4）将基准数2和1进行交换，以基准数2为分界点，2左边的数（1，0）都小于等于2，2右边的数（7，9，6，4，5，3，8）都大于2；

1	0	2	7	9	6	4	5	3	8

（5）递归处理左边序列和右边序列即可。

1	0	2	7	9	6	4	5	3	8

……

0	1	2	3	4	5	6	7	8	9

5.降序排序

当排序改为降序时，只需要修改比较符。我以比较排序为例写了降序排序的代码。

二、众数问题

1.题目要求

对随机生成的由n个自然数组成的多重集合S, 编程计算S的众数及其重数。

2.思路

考虑到需要输出众数及其重数，我想到了Python里的字典。用字典的key来保存数，value保存对应的重数，通过比较value，输出最大的value值及其对应的key值。

第一步，统计每个数字出现的次数，保存在字典中；

第二步，通过max()函数找到字典中的value最大值；

第三步，输出最大value（众数）及其对应的key值（重数）。

三、最近点对问题

1.题目要求

对平面上给定的N个点，给出所有点对的最短距离。

输入：平面上的N个点

输出：N点中具有最短距离的两点。

（1）应用穷举法编程计算出所有点对的最短距离；

（2）应用分治法编程计算出所有点对的最短距离。

2.分治法思路

第一步，把所有点按照x值排序，从最中间（x值中位数b）将所有点分为三个部分，左子域（左子域包括中间子域）、右子域、x值恰好等于中位数的中间子域；

第二步，分别找出左右子域中的最近点，取最小值为d；

第三步，将左右子域的x值范围缩减到[b-d，b+d]之间，循环遍历左子域中的每个点，在右子域中寻找y值离当前点最近的四个点，分别求距离，取最小距离，然后寻找中间子域中的最近点，取最小距离；

第四步，通过递归（分治）的方法，最终正确查找到最近点对。

3.实验结果

输入：p = [[0, 0], [1, 1], [3, 4], [0, 3], [3.2, 4.2], [0, -1], [-2, -2], [-1, -2], [0, 0.4], [-1, 2], [0, 2], [0.5, 2]]

输出：最近点对是 ( 3.2 , 4.2 ) 和 ( 3 , 4 ), 最短距离为 0.2828427124746193

4.小结

穷举法的时间复杂度为O(n^2)

分治法的时间复杂度为O(nlogn)

四、最大子数组问题

1.题目要求：随机给出一个整数序列，选出其中连续且非空的一段使得这段和最大（使用分治法解决）。

2.思路步骤

第一步，分治。将数组分为左右两半，分别求解左右两半的最大子数组。

第二步，合并。计算跨越两边的最大子数组，与左右两边的最大子数组比较，选出最大的。

3.实验结果

输入：A = [13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]

输出：起始位置(从1开始数): 8 终止位置: 11 最大子数组的和为: 43

最大子数组为: [18, 20, -7, 12]

4.小结

穷举法的时间复杂度为O(n^3)，即使经过优化，穷举法的时间复杂度也是O(n^2)，分治法的时间复杂度为O(nlogn)，比分治法更好的方法是动态规划，时间复杂度为O(n)。
